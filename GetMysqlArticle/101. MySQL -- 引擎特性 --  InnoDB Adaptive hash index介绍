<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>MySQL · 引擎特性 ·  InnoDB Adaptive hash index介绍</title>
  <meta name="description" content="前言">

  <link rel="stylesheet" href="/monthly/css/typo.css">
  <link rel="stylesheet" href="/monthly/css/animate.css">
  <link rel="stylesheet" href="/monthly/css/main.css">
  <link rel="canonical" href="http://mysql.taobao.org//monthly/2015/09/01/">
  <link rel="alternate" type="application/rss+xml" title="数据库内核月报" href="http://mysql.taobao.org//monthly/feed.xml" />

  <link rel="stylesheet" href="//cdn.staticfile.org/highlight.js/8.3/styles/tomorrow.min.css">
  <script src="/monthly/js/highlight.min.js"></script>
  <!-- <link rel="stylesheet" href="/monthly/themes/tomorrow.css">
  <script src="/monthly/highlight/highlight.pack.js"> -->
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="http://cdn.staticfile.org/jquery/1.11.1/jquery.min.js"></script>
  <script src="http://cdn.staticfile.org/jquery/1.11.1/jquery.min.map"></script>

  <script src="/monthly/scripts/changeTarget.js"></script>
  
</head>


<!-- Google Analysis -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-62056244-1', 'auto');
  ga('send', 'pageview');
</script>


  <body>

    <header>

  <a id="go-back-home" href="/monthly/2015/09">
    <h1>数据库内核月报 － 2015 / 09</h1>
  </a>

</header>


        <section class="paging">
  
  
  

  
    
  
  
    
      <div class="right">
        <a href="/monthly/2015/09/02/">
          ›
        </a>
      </div>
    
  
</section>


<div id = "container" class = "animated zoomIn">
  <div class="block">
  <nav id="primary_nav_wrap">
<ul>
  <li><a href="#">当期文章</a>
    <ul  class = "animated">
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
            
              <li class="current-menu-item">
            
              <a href="/monthly/2015/09/01/" target="_blank">
                
                MySQL · 引擎特性 ·  InnoDB Adaptive hash index介绍
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/09/02/" target="_blank">
                
                PgSQL · 特性分析 ·  clog异步提交一致性、原子操作与fsync
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/09/03/" target="_blank">
                
                MySQL · 捉虫动态 · BUG 几例
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/09/04/" target="_blank">
                
                PgSQL · 答疑解惑 · 诡异的函数返回值
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/09/05/" target="_blank">
                
                MySQL · 捉虫动态 · 建表过程中crash造成重建表失败
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/09/06/" target="_blank">
                
                PgSQL · 特性分析 · 谈谈checkpoint的调度
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/09/07/" target="_blank">
                
                MySQL · 特性分析 · 5.6 并行复制恢复实现
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/09/08/" target="_blank">
                
                MySQL · 备库优化 ·  relay fetch 备库优化
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/09/09/" target="_blank">
                
                MySQL · 特性分析 · 5.6并行复制事件分发机制
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/09/10/" target="_blank">
                
                MySQL · TokuDB · 文件目录谈
              </a>
            </li>
          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
    </ul>
  </li>
</ul>
</nav>

    <div class="title">
      <h2>
        
        MySQL · 引擎特性 ·  InnoDB Adaptive hash index介绍
      </h2>
    </div>
  </div>
  <div class="content typo">
    <section class="post">
      <h2>前言</h2>

<p>我们知道InnoDB的索引组织结构为Btree。通常情况下，我们需要根据查询条件，从根节点开始寻路到叶子节点，找到满足条件的记录。为了减少寻路开销，InnoDB本身做了几点优化。</p>

<p>首先，对于连续记录扫描，InnoDB在满足比较严格的条件时采用row cache的方式连续读取8条记录（并将记录格式转换成MySQL Format），存储在线程私有的<code>row_prebuilt_t::fetch_cache</code>中；这样一次寻路就可以获取多条记录，在server层处理完一条记录后，可以直接从cache中取数据而无需再次寻路，直到cache中数据取完，再进行下一轮。</p>

<p>另一种方式是，当一次进入InnoDB层获得数据后，在返回server层前，当前在btree上的cursor会被暂时存储到<code>row_prebuilt_t::pcur</code>中，当再次返回InnoDB层捞数据时，如果对应的Block没有发生任何修改，则可以继续沿用之前存储的cursor，无需重新定位。</p>

<p>上面这两种方式都是为了减少了重新寻路的次数，而对于一次寻路的开销，则使用Adaptive hash index来解决。AHI是一个内存结构，严格来说不是传统意义上的索引，可以把它理解为建立在Btree索引上的“索引”。</p>

<p>本文代码分析基于MySQL 5.7.7-rc，描述的逻辑适用于5.7.7之前及5.6版本。但在即将发布的MySQL-5.7.8版本中， InnoDB根据索引id对AHI进行了分区处理，以此来降低btr_search_latch读写锁竞争，由于尚未发布，本文暂不覆盖相关内容。</p>

<p>我们以一个干净启动的实例作为起点，分析下如何进行AHI构建的过程。</p>

<h2>初始化</h2>

<p>AHI在内存中表现就是一个普通的哈希表对象，存储在<code>btr_search_sys_t::hash_index</code>中，对AHI的查删改操作都是通过一个全局读写锁<code>btr_search_latch</code>来保护。</p>

<p>在实例启动，完成buffer pool初始化后，会初始化AHI子系统相关对象，并分配AHI内存，大小为buffer pool的1/64。</p>

<p>参考函数：<code>btr_search_sys_create</code></p>

<p>Tips：MySQL 5.7已经开始支持InnoDB buffer pool的动态调整，其策略是buffer pool的大小改变超过1倍，就重新分配AHI Hash内存（<code>btr_search_sys_resize</code>）。</p>

<h2>触发AHI信息统计</h2>

<p>在系统刚启动时，索引对象上没有足够的信息来启发是否适合进行AHI缓存，因此开始有个信息搜集的阶段，在索引对象上维护了<code>dict_index_t::search_info</code>，类型为<code>btr_search_t</code>，用于跟踪当前索引使用AHI的关键信息。</p>

<p>在第一次执行SQL时，需要从btree的root节点开始，当寻址到匹配的叶子节点时，会走如下逻辑：</p>

<p>btr_cur_search_to_nth_level：</p>

<pre><code class="language-c">if (btr_search_enabled &amp;&amp; !index-&gt;disable_ahi) {
        btr_search_info_update(index, cursor);
}
</code></pre>

<p>这里会判断脏读AHI开关（btr_search_enabled）是否打开，以及<code>index-&gt;diable_ahi</code>是否为false。第二个条件是MySQL5.7对临时表的优化，避免临时表操作对全局对象的影响，针对临时表不做AHI构建。</p>

<p>我们看看函数btr_search_info_update的逻辑：</p>

<ol>
  <li>对<code>info-&gt;hash_analysis++</code>，当<code>info-&gt;hash_analysis</code>值超过<code>BTR_SEARCH_HASH_ANALYSIS</code>（17）时，也就是说对该索引寻路到叶子节点17次后，才会去做AHI分析（进入步骤2）</li>
  <li>进入函数<code>btr_search_info_update_slow</code></li>
</ol>

<p>在连续执行17次对相同索引的操作后，满足<code>info-&gt;hash_analysis</code>大于等于<code>BTR_SEARCH_HASH_ANALYSIS</code>的条件，就会调用函数<code>btr_search_info_update_slow</code>来更新search_info，这主要是为了避免频繁的索引查询分析产生的过多CPU开销。</p>

<p>InnoDB通过索引条件构建一个可用于查询的tuple，而AHI需要根据tuple定位到叶子节点上记录的位置，既然AHI是构建在Btree索引上的索引，它的键值就是通过索引的前N列的值计算的来，所有的信息搜集统计都是为了确定一个合适的”Ｎ” ，这个值也是个动态的值，会跟随应用的负载自适应调整并触发block上的AHI重构建。</p>

<p><code>btr_search_info_update_slow</code>包含三个部分：更新索引查询信息、block上的查询信息以及为当前block构建AHI，下面几小节分别介绍。</p>

<h2>更新索引上的查询信息</h2>

<p>参考函数：<code>btr_search_info_update_hash</code></p>

<p>这里涉及到的几个search_info变量包括：<br />
<code>btr_search_t::n_hash_potential</code>  表示如果使用AHI构建索引，潜在的可能成功的次数；<br />
<code>btr_search_t::hash_analysis </code> 若设置了新的建议前缀索引模式，则重置为0，随后的17次查询分析可以忽略更新search_info。</p>

<p>下面两个字段表示推荐的前缀索引模式：<br />
<code>btr_search_t::n_fields</code>  推荐构建AHI的索引列数；<br />
<code>btr_search_t::left_side</code>  表示是否在相同索引前缀的最左索引记录构建AHI；值为true时，则对于相同前缀索引的记录，只存储最右的那个记录。<br />
通过n_fields和left_side可以指导选择哪些列作为索引前缀来构建（fold, rec）哈希记录。如果用户的SQL的索引前缀列的个数大于等于构建AHI时的前缀索引，就可以用上AHI。</p>

<p>Tip1：在５.7之前的版本中，还支持索引中的字符串前缀作为构建AHI的键值的一部分，但上游认为带来的好处并不明显，因此将<code>btr_search_t::n_bytes</code> 移除了(参见commit <a href="https://github.com/mysql/mysql-server/commit/6f5f19b338543277a108a97710de8dd59b9dbb60" title="Bug#16852278 SIMPLIFY RECORD COMPARISONS">6f5f19b338543277a108a97710de8dd59b9dbb60</a>, <a href="https://github.com/mysql/mysql-server/commit/42499d9394bf103a27d63cd38b0c3c6bd738a7c7" title="Remove support for byte-level prefix granularity in searches.">42499d9394bf103a27d63cd38b0c3c6bd738a7c7</a>）。<br />
Tip2：然而上游在测试中发现，如果把n_bytes移除，可能在诸如顺序插入这样的场景存在性能退化(参阅commit <a href="https://github.com/mysql/mysql-server/commit/00ec81a9efc1108376813f15935b52c451a268cf" title="Bug#21198396 REINTRODUCE ADAPTIVE HASH INDEX FIELD PREFIXES">00ec81a9efc1108376813f15935b52c451a268cf</a>)，因此在新发布的MySQL5.7.8版本中又重新引入，本文分析代码时统一基于MySQL5.7.7版本。</p>

<p>两种情况需要构建建议的前缀索引列：</p>

<ol>
  <li>当前是第一次为该索引做AHI分析，<code>btr_search_t::n_hash_potential</code>值为0，需要构建建议的前缀索引列；</li>
  <li>新的记录匹配模式发生了变化<code>(info-&gt;left_side == (info-&gt;n_fields &lt;=cursor-&gt;low_match))</code>，需要重新设置前缀索引列。</li>
</ol>

<p>相关代码段：</p>

<pre><code class="language-c">if (cursor-&gt;up_match == cursor-&gt;low_match) {
        info-&gt;n_hash_potential = 0; 

        /* For extra safety, we set some sensible values here */

        info-&gt;n_fields = 1; 
        info-&gt;left_side = TRUE;

} else if (cursor-&gt;up_match &gt; cursor-&gt;low_match) {
        info-&gt;n_hash_potential = 1; 

        if (cursor-&gt;up_match &gt;= n_unique) {
                info-&gt;n_fields = n_unique;
        } else if (cursor-&gt;low_match &lt; cursor-&gt;up_match) {
                info-&gt;n_fields = cursor-&gt;low_match + 1; 
        } else {
                info-&gt;n_fields = cursor-&gt;low_match;
        }    

        info-&gt;left_side = TRUE;
} else {
        info-&gt;n_hash_potential = 1; 

        if (cursor-&gt;low_match &gt;= n_unique) {

                info-&gt;n_fields = n_unique;
        } else if (cursor-&gt;low_match &gt; cursor-&gt;up_match) {

                info-&gt;n_fields = cursor-&gt;up_match + 1; 
        } else {
                info-&gt;n_fields = cursor-&gt;up_match;
        }    

        info-&gt;left_side = FALSE;
}
</code></pre>

<p>从上述代码可以看到，在low_match和up_match之间，选择小一点match的索引列数的来进行设置，但不超过唯一确定索引记录值的列的个数：</p>

<ol>
  <li>当low_match小于up_match时，left_side设置为true，表示相同前缀索引的记录只缓存最左记录；</li>
  <li>当low_match大于up_match时，left_side设置为false，表示相同前缀索引的记录只缓存最右记录。</li>
</ol>

<p>如果不是第一次进入seach_info分析，有两种情况会递增<code>btr_search_t::n_hash_potential</code>：</p>

<ul>
  <li>
    <p>本次查询的up_match和当前推荐的前缀索引都能唯一决定一条索引记录(例如唯一索引)，则根据search_info推荐的前缀索引列构建AHI肯定能命中，递增 <code>info-&gt;n_hash_potential</code>；</p>

    <pre><code>  if (info-&gt;n_fields &gt;= n_unique &amp;&amp; cursor-&gt;up_match &gt;= n_unique) {
  increment_potential:
          info-&gt;n_hash_potential++;

          return;
  }
</code></pre>
  </li>
  <li>
    <p>本次查询的tuple可以通过建议的前缀索引列构建的AHI定位到。</p>

    <pre><code>  if (info-&gt;left_side == (info-&gt;n_fields &lt;= cursor-&gt;up_match)) {

          goto increment_potential;
  }
</code></pre>
  </li>
</ul>

<p>很显然，如果对同一个索引的查询交替使用不同的查询模式，可能上次更新的search_info很快就会被重新设置，具有固定模式的索引查询将会受益于AHI索引。</p>

<h2>更新block上的查询信息</h2>

<p>参考函数：<code>btr_search_update_block_hash_info</code></p>

<p>更新数据页block上的查询信息，涉及到修改的变量包括：</p>

<p><code>btr_search_info::last_hash_succ</code> 最近一次成功(或可能成功)使用AHI；<br />
<code>buf_block_t::n_hash_helps</code> 计数值，如果使用当前推荐的前缀索引列构建AHI可能命中的次数，用于启发构建／重新构建数据页上的AHI记录项；<br />
<code>buf_block_t::n_fields</code> 推荐在block上构建AHI的前缀索引列数；<br />
<code>buf_block_t::left_side</code> 和search_info上对应字段含义相同。</p>

<p>函数主要流程包括：</p>

<ol>
  <li>
    <p>首先设置<code>btr_search_info::last_hash_succ</code> 为FALSE<br />
这会导致在分析过程中无法使用AHI进行检索，感觉这里的设置不是很合理。这意味着每次分析一个新的block，都会导致AHI短暂不可用。</p>
  </li>
  <li>
    <p>初始化或更新block上的查询信息</p>

    <pre><code> if ((block-&gt;n_hash_helps &gt; 0)
     &amp;&amp; (info-&gt;n_hash_potential &gt; 0)
     &amp;&amp; (block-&gt;n_fields == info-&gt;n_fields)
     &amp;&amp; (block-&gt;left_side == info-&gt;left_side)) {

         if ((block-&gt;index)
             &amp;&amp; (block-&gt;curr_n_fields == info-&gt;n_fields)
             &amp;&amp; (block-&gt;curr_left_side == info-&gt;left_side)) {

                 /* The search would presumably have succeeded using
                 the hash index */

                 info-&gt;last_hash_succ = TRUE;
         }

         block-&gt;n_hash_helps++;
 } else {
         block-&gt;n_hash_helps = 1;
         block-&gt;n_fields = info-&gt;n_fields;
         block-&gt;left_side = info-&gt;left_side;
 }
</code></pre>

    <p>当block第一次被touch到并进入该函数时，设置block上的建议索引列值；以后再进入时，如果和索引上的全局search_info相匹配，则递增<code>block-&gt;n_hash_helps</code>，启发后续的创建或重构建AHI。</p>

    <p>如果当前数据页block上已经构建了AHI记录项，且<code>buf_block_t::curr_n_fields</code>等字段和<code>btr_search_info</code>上对应字段值相同时，则认为当前SQL如果使用AHI索引能够命中，因此将<code>btr_search_info::last_hash_succ</code>设置为true，下次再使用相同索引检索btree时就会尝试使用AHI。</p>
  </li>
  <li>
    <p>在初始化或更新block上的变量后，需要判断是否为整个page构建AHI索引：</p>

    <pre><code> if ((block-&gt;n_hash_helps &gt; page_get_n_recs(block-&gt;frame)
      / BTR_SEARCH_PAGE_BUILD_LIMIT)
     &amp;&amp; (info-&gt;n_hash_potential &gt;= BTR_SEARCH_BUILD_LIMIT)) {

         if ((!block-&gt;index)
             || (block-&gt;n_hash_helps
                 &gt; 2 * page_get_n_recs(block-&gt;frame))
             || (block-&gt;n_fields != block-&gt;curr_n_fields)
             || (block-&gt;left_side != block-&gt;curr_left_side)) {

                 /* Build a new hash index on the page */

                 return(TRUE);
         }
 }
</code></pre>

    <p>简单来说，当满足下面三个条件时，就会去为整个block上构建AHI记录项：</p>

    <ul>
      <li>分析使用AHI可以成功查询的次数(<code>buf_block_t::n_hash_helps</code>)超过block上记录数的16(<code>BTR_SEARCH_PAGE_BUILD_LIMIT</code>)分之一；</li>
      <li><code>btr_search_info::n_hash_potential</code>大于等于<code>BTR_SEARCH_BUILD_LIMIT</code> (100)，表示连续100次潜在的成功使用AHI可能性；</li>
      <li>尚未为当前block构造过索引、或者当前block上已经构建了AHI索引且<code>block-&gt;n_hash_helps</code>大于page上记录数的两倍、或者当前block上推荐的前缀索引列发生了变化 。</li>
    </ul>
  </li>
</ol>

<h2>为数据页构建AHI索引</h2>

<p>如果在上一阶段判断认为可以为当前page构建AHI索引（函数<code>btr_search_update_block_hash_info</code>返回值为TRUE），则根据当前推荐的索引前缀进行AHI构建。</p>

<p>参考函数：<code>btr_search_build_page_hash_index</code></p>

<p>分为三个阶段：</p>

<ol>
  <li>
    <p><strong>检查阶段</strong>：加btr_search_latch的S锁，判断AHI开关是否打开；如果block上已经构建了老的AHI但前缀索引列和当前推荐的不同，则清空Block对应的AHI记录项（<code>btr_search_drop_page_hash_index</code>）；检查n_fields和page上的记录数；然后释放btr_search_latch的S锁；</p>
  </li>
  <li>
    <p><strong>搜集阶段</strong>：根据推荐的索引列数计算记录fold值，将对应的数据页记录内存地址到数组里；</p>

    <p>根据left_mode值，相同的前缀索引列值会有不同的行为，举个简单的例子，假设page上记录为 (2,1), (2,2), (5, 3), (5, 4), (7, 5), (8, 6)，n_fields＝１</p>

    <ul>
      <li>若left_most为true，则hash存储的记录为(2,1) , (5, 3), (7, 5), (8,6)</li>
      <li>若left_most为false，则hash存储的记录为(2, 2), (5, 4), (7,5), (8, 6)</li>
    </ul>
  </li>
  <li>
    <p><strong>插入阶段</strong>：加btr_search_latch的X锁，将第二阶段搜集的(fold, rec)插入到AHI中，并更新：</p>

    <pre><code> if (!block-&gt;index) {
         index-&gt;search_info-&gt;ref_count++;
 }

 block-&gt;n_hash_helps = 0;

 block-&gt;curr_n_fields = n_fields;
 block-&gt;curr_left_side = left_side;
 block-&gt;index = index;
</code></pre>
  </li>
</ol>

<p>PS：由于第二阶段释放了btr_search_latch锁，这里还得判断block上的AHI信息是否发生了变化，如果block上已经构建了AHI且block-&gt;curr_*几个变量和当前尝试构建的检索模式不同，则放弃本次构建。</p>

<h2>使用AHI</h2>

<p>AHI的目的是根据用户提供的查询条件加速定位到叶子节点，一般如果有固定的查询pattern，都可以通过AHI受益，尤其是Btree高度比较大的时候。</p>

<p>入口函数：<code>btr_cur_search_to_nth_level</code></p>

<p>相关代码：</p>

<pre><code class="language-C">        /* Use of AHI is disabled for intrinsic table as these tables re-use
        the index-id and AHI validation is based on index-id. */
        if (rw_lock_get_writer(&amp;btr_search_latch) == RW_LOCK_NOT_LOCKED
            &amp;&amp; latch_mode &lt;= BTR_MODIFY_LEAF
            &amp;&amp; info-&gt;last_hash_succ
            &amp;&amp; !index-&gt;disable_ahi
            &amp;&amp; !estimate
# ifdef PAGE_CUR_LE_OR_EXTENDS
            &amp;&amp; mode != PAGE_CUR_LE_OR_EXTENDS
# endif /* PAGE_CUR_LE_OR_EXTENDS */
            &amp;&amp; !dict_index_is_spatial(index)
            /* If !has_search_latch, we do a dirty read of
            btr_search_enabled below, and btr_search_guess_on_hash()
            will have to check it again. */
            &amp;&amp; UNIV_LIKELY(btr_search_enabled)
            &amp;&amp; !modify_external
            &amp;&amp; btr_search_guess_on_hash(index, info, tuple, mode,
                                        latch_mode, cursor,
                                        has_search_latch, mtr)) {
</code></pre>

<p>从代码段可以看出，需要满足如下条件才能够使用AHI：</p>

<ul>
  <li>没有加btr_search_latch写锁。如果加了写锁，可能操作时间比较耗时，走AHI检索记录就得不偿失了；</li>
  <li>latch_mode &lt;= BTR_MODIFY_LEAF，表明本次只是一次不变更BTREE结构的DML或查询（包括等值、RANGE等查询）操作；</li>
  <li><code>btr_search_info::last_hash_succ</code>为true表示最近一次使用AHI成功（或可能成功）了；</li>
  <li>打开AHI开关；</li>
  <li>查询优化阶段的估值操作，例如计算range范围等，典型的堆栈包括：<code>handler::multi_range_read_info_const</code>　–&gt; <code>ha_innobase::records_in_range</code> –&gt; <code>btr_estimate_n_rows_in_range</code> –&gt; <code>btr_cur_search_to_nth_level</code>；</li>
  <li>不是spatial索引；</li>
  <li>调用者无需分配外部存储页(BTR_MODIFY_EXTERNAL，主要用于辅助写入大的blob数据，参考struct btr_blob_log_check_t)。</li>
</ul>

<p>当满足上述条件时，进入函数<code>btr_search_guess_on_hash</code>，根据当前的查询tuple对象计算fold，并查询AHI；只有当前检索使用的tuple列的个数大于等于构建AHI的列的个数时，才能够使用AHI索引。</p>

<p><code>btr_search_guess_on_hash</code>：</p>

<ul>
  <li>首先用户提供的前缀索引查询条件必须大于等于构建AHI时的前缀索引列数，这里存在一种可能性：索引上的search_info的n_fields 和block上构建AHI时的cur_n_fields值已经不相同了，但是我们并不知道本次查询到底落在哪个block上，这里一致以search_info上的n_fields为准来计算fold，去查询AHI；</li>
  <li>在检索AHI时需要加&amp;btr_search_latch的S锁；</li>
  <li>如果本次无法命中AHI，就会将<code>btr_search_info::last_hash_succ</code>设置为false，这意味着随后的查询都不会去使用AHI了，只能等待下一路查询信息分析后才可能再次启动（<code>btr_search_failure</code>）；</li>
  <li>对于从ahi中获得的记录指针，还需要根据当前的查询模式检查是否是正确的记录位置（<code>btr_search_check_guess</code>）。</li>
</ul>

<p>如果本次查询使用了AHI，但查询失败了（<code>cursor-&gt;flag == BTR_CUR_HASH_FAIL</code>），并且当前block构建AHI索引的curr_n_fields等字段和btr_search_info上的相符合，则根据当前cursor定位到的记录插入AHI。参考函数：<code>btr_search_update_hash_ref</code>。</p>

<p>从上述分析可见，AHI如其名，完全是自适应的，如果检索模式不固定，很容易就出现无法用上AHI或者AHI失效的情况。</p>

<h2>维护AHI</h2>

<ol>
  <li>
    <p>关闭选项innodb_adaptive_hash_index；</p>

    <ul>
      <li>持有<code>dict_sys-&gt;mutex</code>和<code>btr_search_latch</code>的X锁；</li>
      <li>遍历<code>dict_sys-&gt;table_LRU</code>和<code>dict_sys-&gt;table_non_LRU</code>链表，将每个表上的所有索引的<code>index-&gt;search_info-&gt;ref_count</code>设置为0；</li>
      <li>释放<code>dict_sys-&gt;mutex</code>；</li>
      <li>遍历buffer pool，将block上的index标记(<code>buf_block_t::index</code>)清空为NULL；</li>
      <li>清空AHI中的哈希项，并释放为记录项分配的Heap；</li>
      <li>释放btr_search_latch。</li>
    </ul>

    <p>参考函数：<code>btr_search_disable</code></p>
  </li>
  <li>
    <p><code>index-&gt;search_info</code>的ref_count不为0时，无法从数据集词典cache中将对应的表驱逐，workaround的方式是临时关闭AHI开关；</p>

    <p>参考函数：<code>dict_table_can_be_evicted</code>、<code>dict_index_remove_from_cache_low</code></p>
  </li>
  <li>
    <p>删除索引页上的记录，或者更新的是二级索引、或者更新了主键且影响了排序键值，则需要从AHI上将对应的索引记录删除；</p>

    <p>参考函数：<code>btr_search_update_hash_on_delete</code></p>
  </li>
  <li>
    <p>插入新的记录时，如果本次插入未产生页面重组、操作的page为叶子节点，且本次插入操作使用过AHI定位成功，则先尝试更新再尝试插入，否则直接插入对应的AHI记录项；</p>

    <p>参考函数：<code>btr_search_update_hash_node_on_insert</code>、<code>btr_search_update_hash_on_insert</code></p>
  </li>
  <li>
    <p>涉及索引树分裂或者节点合并，或从LRU中驱逐page（buf_LRU_free_page）时，需要清空AHI对应的page。</p>

    <p>参考函数：<code>btr_search_drop_page_hash_index</code></p>
  </li>
</ol>

<h2>shortcut查询模式</h2>

<p>在<code>row_search_mvcc</code>函数中，首先会去判断在满足一定条件时，使用shortcut模式，利用AHI索引来进行检索。</p>

<p>只有满足严苛的条件时（例如需要唯一键查询、使用聚集索引、长度不超过八分之一的page size、隔离级别在RC及RC之上、活跃的Read view等等条件，具体的参阅代码），才能使用shortcut：</p>

<ul>
  <li>加<code>btr_search_latch</code>的S锁；</li>
  <li>然后通过<code>row_sel_try_search_shortcut_for_mysql</code>检索记录；如果找到满足条件的记录，本次查询可以不释放 btr_search_latch，这意味着InnoDB/server层交互期间可能持有AHI锁，但最多在10000次（BTR_SEA_TIMEOUT）交互后释放AHI latch。一旦发现有别的线程在等待AHI X 锁，也会主动释放其拥有的S锁。</li>
</ul>

<p>然而， Percona的开发Alexey Kopytov认为这种长时间拥有的<code>btr_search_latch</code>的方式是没有必要的，这种设计方式出现在很久之前加锁、解锁非常昂贵的时代，然而现在的CPU已经很先进了，完全没有必要，在Percona的版本中，一次shortcut的查询操作后都直接释放掉<code>btr_search_latch</code>（参阅<a href="https://bugs.launchpad.net/percona-server/+bug/1218347">bug#1218347</a>）。</p>

<h2>AHI监控项</h2>

<p>我们可以通过<code>information_schema.innodb_metrics</code>来监控AHI模块的运行状态</p>

<p>首先打开监控：</p>

<pre><code class="language-SQL">mysql&gt;  set global innodb_monitor_enable = module_adaptive_hash;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select status, name, subsystem from INNODB_METRICS where subsystem like '%adaptive_hash%';
+---------+------------------------------------------+---------------------+
| status  | name                                     | subsystem           |
+---------+------------------------------------------+---------------------+
| enabled | adaptive_hash_searches                   | adaptive_hash_index |
| enabled | adaptive_hash_searches_btree             | adaptive_hash_index |
| enabled | adaptive_hash_pages_added                | adaptive_hash_index |
| enabled | adaptive_hash_pages_removed              | adaptive_hash_index |
| enabled | adaptive_hash_rows_added                 | adaptive_hash_index |
| enabled | adaptive_hash_rows_removed               | adaptive_hash_index |
| enabled | adaptive_hash_rows_deleted_no_hash_entry | adaptive_hash_index |
| enabled | adaptive_hash_rows_updated               | adaptive_hash_index |
+---------+------------------------------------------+---------------------+
8 rows in set (0.00 sec)
</code></pre>

<p>重置所有的计数</p>

<pre><code class="language-SQL">mysql&gt; set global innodb_monitor_reset_all = 'adaptive_hash%';
Query OK, 0 rows affected (0.00 sec)
</code></pre>
<p>该表搜集了AHI子系统诸如AHI查询次数，更新次数等信息，可以很好的监控其运行状态，在某些负载下，AHI并不适合打开，关闭AHI可以避免额外的维护开销。当然这取决于你针对具体负载的性能测试。</p>

    </section>
  </div>
</div>


    <footer>
  <a href="http://mysql.taobao.org/" target="_blank" class="muted">阿里云RDS-数据库内核组</a>
  <br>
  <a href="https://github.com/alibaba/AliSQL" target="_blank" class="muted">欢迎在github上star AliSQL</a>
</br>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">知识共享署名-非商业性使用-相同方式共享 3.0 未本地化版本许可协议</a>进行许可。
</footer>

<script type="text/javascript">
  jQuery(document).ready(function($){
    // browser window scroll (in pixels) after which the "back to top" link is shown
    var offset = 300,
      //browser window scroll (in pixels) after which the "back to top" link opacity is reduced
      offset_opacity = 1200,
      //duration of the top scrolling animation (in ms)
      scroll_top_duration = 700,
      //grab the "back to top" link
      $back_to_top = $('.cd-top');

    //hide or show the "back to top" link
    $(window).scroll(function(){
      ( $(this).scrollTop() > offset ) ? $back_to_top.addClass('cd-is-visible') : $back_to_top.removeClass('cd-is-visible cd-fade-out');
      if( $(this).scrollTop() > offset_opacity ) {
        $back_to_top.addClass('cd-fade-out');
      }
    });

    //smooth scroll to top
    $back_to_top.on('click', function(event){
      event.preventDefault();
      $('body,html').animate({
        scrollTop: 0 ,
        }, scroll_top_duration
      );
    });

  });
</script>



    <a href="#0" class="cd-top"><svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="10px"
   width="38px" height="60px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
      <polygon fill="#FFFFFF" points="8,2.8 16,10.7 13.6,13.1 8.1,7.6 2.5,13.2 0,10.7 "/>
    </svg>
    </a>
  </body>

</html>
