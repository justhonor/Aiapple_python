<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>MySQL · 引擎特性 · InnoDB 全文索引简介</title>
  <meta name="description" content="前言">

  <link rel="stylesheet" href="/monthly/css/typo.css">
  <link rel="stylesheet" href="/monthly/css/animate.css">
  <link rel="stylesheet" href="/monthly/css/main.css">
  <link rel="canonical" href="http://mysql.taobao.org//monthly/2015/10/01/">
  <link rel="alternate" type="application/rss+xml" title="数据库内核月报" href="http://mysql.taobao.org//monthly/feed.xml" />

  <link rel="stylesheet" href="//cdn.staticfile.org/highlight.js/8.3/styles/tomorrow.min.css">
  <script src="/monthly/js/highlight.min.js"></script>
  <!-- <link rel="stylesheet" href="/monthly/themes/tomorrow.css">
  <script src="/monthly/highlight/highlight.pack.js"> -->
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="http://cdn.staticfile.org/jquery/1.11.1/jquery.min.js"></script>
  <script src="http://cdn.staticfile.org/jquery/1.11.1/jquery.min.map"></script>

  <script src="/monthly/scripts/changeTarget.js"></script>
  
</head>


<!-- Google Analysis -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-62056244-1', 'auto');
  ga('send', 'pageview');
</script>


  <body>

    <header>

  <a id="go-back-home" href="/monthly/2015/10">
    <h1>数据库内核月报 － 2015 / 10</h1>
  </a>

</header>


        <section class="paging">
  
  
  

  
    
  
  
    
      <div class="right">
        <a href="/monthly/2015/10/02/">
          ›
        </a>
      </div>
    
  
</section>


<div id = "container" class = "animated zoomIn">
  <div class="block">
  <nav id="primary_nav_wrap">
<ul>
  <li><a href="#">当期文章</a>
    <ul  class = "animated">
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
            
              <li class="current-menu-item">
            
              <a href="/monthly/2015/10/01/" target="_blank">
                
                MySQL · 引擎特性 · InnoDB 全文索引简介
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/10/02/" target="_blank">
                
                MySQL · 特性分析 · 跟踪Metadata lock
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/10/03/" target="_blank">
                
                MySQL · 答疑解惑 · 索引过滤性太差引起CPU飙高分析
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/10/04/" target="_blank">
                
                PgSQL · 特性分析 · PG主备流复制机制
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/10/05/" target="_blank">
                
                MySQL · 捉虫动态 · start slave crash 诊断分析
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/10/06/" target="_blank">
                
                MySQL · 捉虫动态 · 删除索引导致表无法打开
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/10/07/" target="_blank">
                
                PgSQL · 特性分析 · PostgreSQL Aurora方案与DEMO
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/10/08/" target="_blank">
                
                TokuDB · 捉虫动态 · CREATE DATABASE 导致crash问题
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/10/09/" target="_blank">
                
                PgSQL · 特性分析 · pg_receivexlog工具解析
              </a>
            </li>
          
      
          
          

          
            
              <li>
            
              <a href="/monthly/2015/10/10/" target="_blank">
                
                MySQL · 特性分析 · MySQL权限存储与管理
              </a>
            </li>
          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
          
          

          
      
    </ul>
  </li>
</ul>
</nav>

    <div class="title">
      <h2>
        
        MySQL · 引擎特性 · InnoDB 全文索引简介
      </h2>
    </div>
  </div>
  <div class="content typo">
    <section class="post">
      <h2>前言</h2>

<p>从MySQL5.6版本开始支持InnoDB引擎的全文索引，语法层面上大多数兼容之前MyISAM的全文索引模式。所谓全文索引，是一种通过建立倒排索引，快速匹配文档的方式。MySQL支持三种模式的全文检索模式：</p>

<ol>
  <li>自然语言模式（<a href="http://dev.mysql.com/doc/refman/5.7/en/fulltext-natural-language.html">IN NATURAL LANGUAGE MODE</a>），即通过MATCH AGAINST 传递某个特定的字符串来进行检索。</li>
  <li>
    <p>布尔模式（<a href="http://dev.mysql.com/doc/refman/5.7/en/fulltext-boolean.html">IN BOOLEAN MODE</a>），可以为检索的字符串增加操作符，例如“+”表示必须包含，“-”表示不包含，“*”表示通配符（这种情况，   即使传递的字符串较小或出现在停词中，也不会被过滤掉），其他还有很多特殊的布尔操作符，可以通过如下参数控制：</p>

    <pre><code> mysql&gt; show variables like '%ft_boolean_syntax%';
 +-------------------+----------------+
 | Variable_name     | Value          |
 +-------------------+----------------+
 | ft_boolean_syntax | + -&gt;&lt;()~*:""&amp;| |
 +-------------------+----------------+
 1 row in set (0.00 sec)
</code></pre>
  </li>
  <li>查询扩展模式（<a href="http://dev.mysql.com/doc/refman/5.7/en/fulltext-query-expansion.html">WITH QUERY EXPANSION</a>）, 这种模式是自然语言模式下的一个变种，会执行两次检索，第一次使用给定的短语进行检索，第二次是结合第一次相关性比较高的行进行检索。</li>
</ol>

<p>目前MySQL支持在CHAR、VARCHAR、TEXT类型的列上定义全文索引。</p>

<p>本文只是简单的分析了全文索引涉及到的代码模块以及5.7的一些新特性，源码部分基于MySQL5.7.8-rc版本，更细节的部分并未深入。</p>

<h2>创建全文索引</h2>

<p>如下例所示，一个简单的创建带全文索引表的SQL：</p>

<pre><code>create table t1 (a int auto_increment primary key, b text, fulltext(b));
</code></pre>

<p>磁盘上会产生多个文件：</p>

<pre><code>$ls -lh /u01/my57/data/test/
total 1.3M

 FTS_000000000000010b_0000000000000154_INDEX_1.ibd
 FTS_000000000000010b_0000000000000154_INDEX_2.ibd
 FTS_000000000000010b_0000000000000154_INDEX_3.ibd
 FTS_000000000000010b_0000000000000154_INDEX_4.ibd
 FTS_000000000000010b_0000000000000154_INDEX_5.ibd
 FTS_000000000000010b_0000000000000154_INDEX_6.ibd
 FTS_000000000000010b_BEING_DELETED_CACHE.ibd
 FTS_000000000000010b_BEING_DELETED.ibd
 FTS_000000000000010b_CONFIG.ibd
 FTS_000000000000010b_DELETED_CACHE.ibd
 FTS_000000000000010b_DELETED.ibd
 t1.frm
 t1.ibd
</code></pre>

<p>除了t1.frm和t1.ibd外，共分为以下几类表</p>

<ol>
  <li>
    <p>FTS_000000000000010b_0000000000000154_INDEX_1~6.ibd这6个文件用于存储倒排索引，存储的是分词和位置以及document ID，根据分词的第一个字符值进行分区，映射到不同的文件中；<br />
文件的命名规则为FTS_{TABLE_ID}_{INDEX_ID}_INDEX_{N}.ibd</p>
  </li>
  <li>
    <p>FTS_000000000000010b_DELETED.ibd 包含已经被删除的DOC_ID，但还没从全文索引数据中删掉；<br />
FTS_000000000000010b_DELETED_CACHE.ibd 是前者的内存缓存（但是搜索了下代码，只有当<code>fts_cache_t::deleted_doc_ids</code>被使用时，才会在sync时转储到该表中，但并没有发现任何地方使用这个对象）</p>
  </li>
  <li>
    <p>FTS_000000000000010b_BEING_DELETED_CACHE.ibd 和 FTS_000000000000010b_BEING_DELETED.ibd，包含了已经被删除索引记录并且正在从全文索引中移除的DOC ID，前者是后者的内存版本，这两个表主要用于辅助进行OPTIMIZE TABLE时将DELETED/DELETED_CACHED表中的记录转储到其中。</p>
  </li>
  <li>
    <p>FTS_000000000000010b_CONFIG.ibd，包含全文索引的内部信息，最重要的存储是FTS_SYNCED_DOC_ID，表示已经解析并刷到磁盘的doc id， 在崩溃恢复时，可以根据这个值判断哪些该重新解析并加入到索引cache中。</p>
  </li>
</ol>

<p>建全文索引辅助表函数参考：</p>

<pre><code class="language-c">ha_innobase::create
     |--&gt; create_table_info_t::create_table
            |--&gt; fts_create_common_tables
</code></pre>

<p>当对一个已经存在的表上创建全文索引时，InnoDB采用了fork多个线程进行并发构建全文索引项的方法，并发度由参数 <code>innodb_ft_sort_pll_degree</code> 控制。因此在restore一个全文索引表时，我们建议先建表、导入数据，再在表上创建全文索引。</p>

<p>参考函数：<code>row_merge_read_clustered_index --&gt; row_fts_start_psort</code><br />
线程回调函数为<code>fts_parallel_tokenization</code>。</p>

<p>当表上存在全文索引时，就会隐式的建立一个名为FTS_DOC_ID的列，并在其上创建一个唯一索引，用于标识分词出现的记录行。你也可以显式的创建一个名为FTS_DOC_ID的列，但需要和隐式创建的列类型保持一致。</p>

<p>为了维护表上的全文索引信息，全文索引模块定义了大量的类来进行管理，总的来说如下图所示：</p>

<!-- _includes/image.html -->
<div class="image-wrapper">
    

    
        <img src="/monthly/pic/2015-10-01/dict_ft.png" alt="全文索引模块" />
    

    

    
        <p class="image-caption">图1. 全文索引模块</p>
    
</div>

<h2>普通DML及查询操作</h2>

<h3>插入</h3>

<p>我们可以通过INNODB_FT_INDEX_CACHE来检查插入记录的分词：</p>

<pre><code>mysql&gt; insert into  t1 values (NULL, 'hello, welcome to mysql world');
Query OK, 1 row affected (1.87 sec)

mysql&gt; set global innodb_ft_aux_table = 'test/t1';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; select * from INNODB_FT_INDEX_CACHE;
+---------+--------------+-------------+-----------+--------+----------+
| WORD    | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+---------+--------------+-------------+-----------+--------+----------+
| hello   |            2 |           2 |         1 |      2 |        0 |
| mysql   |            2 |           2 |         1 |      2 |       18 |
| welcome |            2 |           2 |         1 |      2 |        7 |
| world   |            2 |           2 |         1 |      2 |       24 |
+---------+--------------+-------------+-----------+--------+----------+
4 rows in set (0.00 sec)
</code></pre>

<p>在插入一条记录时，对应的堆栈如下：</p>

<pre><code class="language-c">row_insert_for_mysql
     |--&gt; row_insert_for_mysql_using_ins_graph
            |--&gt; fts_trx_add_op  // state = FTS_INSERT
</code></pre>

<p>在向原表上插入完成记录后，会去判断表上是否有全文索引（DICT_TF2_FTS），如果有的话，则将插入记录对应的doc id提取出来(<code>fts_get_doc_id_from_row</code>)，并缓存到事务对象中。</p>

<h3>删除</h3>

<p>删除操作不会直接从全文索引里直接删除，因此依然可以从INNODB_FT_INDEX_CACHE中查到分词信息。</p>

<p>相关堆栈：</p>

<pre><code class="language-c">ha_innobase::delete_row
     |--&gt; row_update_for_mysql
            |--&gt; row_update_for_mysql_using_upd_graph
                   |--&gt; row_fts_update_or_delete
                          |--&gt; fts_trx_add_op // state = FTS_DELETE
</code></pre>

<h3>更新</h3>

<p>更新非全文索引列，不会修改FTS_DOC_ID列的值。如果更新了全文索引列，在InnoDB的实现是删除老的DOC，并插入新的DOC。</p>

<p>堆栈为：</p>

<pre><code class="language-c">ha_innobase::update_row
     |--&gt; row_update_for_mysql
           |--&gt; row_update_for_mysql_using_upd_graph
                  |--&gt; row_fts_update_or_delete
                         |--&gt; row_fts_do_update
                                |--&gt; fts_trx_add_op // state = FTS_DELETE
                                |--&gt; fts_trx_add_op // state = FTS_INSERT
</code></pre>

<p>可见所有DML的操作，都走接口函数<code>fts_trx_add_op</code>，划分为两种操作: FTS_INSERT及FTS_DELETE；当前事务涉及的doc id被存储到<code>trx-&gt;fts_trx</code>中，在执行SQL的过程中并没有更新全文索引，而是在事务提交时进行的。</p>

<p>在缓存操作时，维护了两个结构，一个是<code>trx-&gt;fts_trx-&gt;savepoints</code>，维护了事务全局的全文索引操作，另外一个是<code>trx-&gt;fts_trx-&gt;last_stmt</code>，维护的是当前SQL操作的doc id，前者在事务结束时处理，后者在SQL结束时清空。</p>

<h3>查询</h3>

<p>对于全文索引的查询，采用新的接口函数，分为两步:</p>

<ol>
  <li>
    <p>根据检索词搜集符合条件的doc id。</p>

    <pre><code> JOIN::optimize
     |--&gt; init_ftfuncs
          |--&gt; Item_func_match::init_search
                 |--&gt; ha_innobase::ft_init_ext
                        |--&gt; fts_query
</code></pre>

    <p>在搜集满足查询条件的doc id时，首先读取DELETED表中记录的doc id，这些doc id随后被用做过滤。</p>
  </li>
  <li>
    <p>根据搜集到的doc id，找到对应的记录，使用的索引是<code>dict_table_t::fts_doc_id_index</code>，也就是建立在隐藏列FTS_DOC_ID上的唯一索引。</p>

    <pre><code> sub_select
      |--&gt; join_ft_read_first
             |--&gt; ha_innobase::ft_init
             |--&gt; ha_innobase::ft_read
      |--&gt; join_ft_read_next
             |--&gt; ha_innobase::ft_read
</code></pre>
  </li>
</ol>

<p>通常查询返回的结果是根据rank排序的，InnoDB的全文检索排序规则和sphinx类似，基于 BM25 和 TF-IDF算法。</p>

<p>rank的计算算法如下：</p>

<pre><code>${IDF} = log10( ${total_records} / ${matching_records} )  // total_records表示总的行记录数，matching_records表示匹配到检索字的行记录数
${TF} 表示单词在文档中出现的次数

${rank} = ${TF} * ${IDF} * ${IDF}
</code></pre>

<p>IDF的计算参阅函数：<code>fts_query_calculate_idf</code><br />
ranking计算：<code>fts_query_calculate_ranking</code></p>

<p>如果使用多个单词匹配，则把各个单词各自的rank累加起来。官方博客有<a href="http://mysqlserverteam.com/rankings-with-innodb-full-text-search/">一篇文章</a>专门对此进行了介绍。</p>

<h2>事务操作</h2>

<p><strong>事务内回滚</strong><br />
正在事务内回滚某个语句，或者回滚到某个savepoint时，需要将对应的操作记录也要删除。维护了<code>trx-&gt;fts_trx-&gt;last_stmt</code>，在单条SQL结束时释放(<code>trx_mark_sql_stat_end</code>)。如果SQL回滚，就根据last_stmt中维护的doc id从全局savepoints中清理掉本条SQL的doc id。</p>

<p>相关堆栈：</p>

<pre><code class="language-c">innobase_rollback --&gt; trx_rollback_last_sql_stat_for_mysql
                                        |--&gt; fts_savepoint_rollback_last_stmt
                                                  |--&gt; fts_undo_last_stmt
                                        |--&gt; trx_mark_sql_stat_end
                                                  |--&gt; fts_savepoint_laststmt_refresh
</code></pre>

<p><strong>回滚到savepoint</strong></p>

<pre><code class="language-c">innobase_rollback_to_savepoint
          |--&gt; fts_savepoint_rollback
</code></pre>

<p><strong>事务提交</strong></p>

<p>相关堆栈：</p>

<pre><code class="language-c">trx_commit_low
      |--&gt; fts_commit  // 处理trx-&gt;fts_trx-&gt;savepoints中缓存的全文索引操作
             |--&gt; fts_commit_table
                    |--&gt; fts_add
                           |--&gt; fts_add_doc_by_id
                    |--&gt; fts_delete
      |--&gt; trx_commit_in_memory
             |--&gt; trx_finalize_for_fts
                    |--&gt; trx_finalize_for_fts_table
</code></pre>

<p>在调用fts_commit时，会根据不同的操作类型，调用fts_add增加全文索引项，调用fts_delete删除全文索引项。</p>

<p>由于在插入记录时，先分词、分解成多个词插入辅助表中，因此一条insert可能产生多个小的插入，这种写入放大可能是不可承受的。InnoDB采用了一种优化的方案：创建一个内存cache，临时缓存插入操作，当cache满时再批量刷到磁盘，这样做的好处是：</p>

<ul>
  <li>避免重复存储相同的单词；</li>
  <li>cache size 通过参数<code>innodb_ft_cache_size</code>控制；</li>
  <li>查询会将cache和磁盘数据进行merge。</li>
</ul>

<p>在事务提交时，调用函数<code>fts_add_doc_by_id</code>：</p>

<ul>
  <li>首先根据doc id，使用doc_id所在的索引进行查询，找到刚刚插入的记录项对应的聚集索引记录；</li>
  <li>遍历表上全部的聚集索引，根据全文索引对应的<code>fts_get_doc_t</code>(<code>fts_cache_t::get_docs</code>)构建<code>fts_doc_t</code>，对文档根据选择的parser进行分词(<code>fts_tokenize_document</code>函数或者<code>fts_tokenize_document_next</code>)，具体的文档存储到<code>fts_doc_t::text</code>中；</li>
  <li>将上一步获得的分词加入到cache中（<code>fts_cache_add_doc</code>）；</li>
  <li>如果当前cache的大小超过配置的<code>innodb_ft_cache_size</code>，或者全局cache的大小超过<code>innodb_ft_total_cache_size</code>(<code>fts_need_sync</code>被设置为true)，则进行一次sync，将该表缓存的数据刷到全文索引文件中(fts_sync)，并清空cache。</li>
</ul>

<p>和插入相似，删除操作也可能产生大量小的删除操作，为了避免这种情况，维持一个表，来记录被删除的doc id，但记录依然存在于原文件中。删除操作的提交函数为<code>fts_delete</code>，将被删除的记录doc_id插入到DELETED辅助表中。</p>

<p>事务模块涉及的几个关键类包括：<br />
<!-- _includes/image.html --></p>
<div class="image-wrapper">
    

    
        <img src="/monthly/pic/2015-10-01/trx_ft.png" alt="全文索引事务模块" />
    

    

    
        <p class="image-caption">图2. 全文索引事务模块</p>
    
</div>

<h2>同步缓存</h2>

<p>在满足一定条件时，全文索引需要进行一次sync操作，将数据同步到全文索引文件中，大概包含以下集中情况需要sync：</p>

<ul>
  <li>cache数据占用的内存超过限制；</li>
  <li>后台线程<code>fts_optimize_thread</code>在shutdown调用，将所有表进行一次sync；</li>
  <li><code>ha_innobase::optimize</code>调用（执行optimize table）；</li>
  <li><code>row_merge_read_clustered_index</code>：创建一个新的临时表并读入数据后，进行一次sync调用。</li>
</ul>

<p>同步操作的入口函数为fts_sync，大体流程为：</p>

<ul>
  <li>针对每个索引，调用函数<code>fts_sync_index</code>：通过函数<code>fts_select_index</code>计算写入的索引文件，再将分词节点信息写入到文件（函数<code>fts_write_node</code>）, 倒排索引的记录内容使用结构体<code>fts_node_t</code>进行描述，存储结构如下图所示：<br />
<!-- _includes/image.html --></li>
</ul>
<div class="image-wrapper">
    

    
        <img src="/monthly/pic/2015-10-01/fts_node.png" alt="倒排索引结点存储结构" />
    

    

    
        <p class="image-caption">图3. 倒排索引结点存储结构</p>
    
</div>

<ul>
  <li>调用<code>fts_sync_commit</code>提交sync操作：
    <ul>
      <li>更新CONFIG表记录的最大SYNC的DOC ID（<code>fts_cmp_set_sync_doc_id</code>）；</li>
      <li>若<code>fts_cache_t::deleted_doc_ids</code>不为空，将其加入到DELETED_CACHE辅助表中（<code>fts_sync_add_deleted_cache</code>）；</li>
      <li>清空cache 并重新初始化。</li>
    </ul>
  </li>
</ul>

<h2>Optimize table</h2>

<p>当你修改了某些配置（例如最小token size时），或者希望重组全文索引时，可以执行optimize table。由于原始optimize table操作会产生整个表的重建，耗时太久，因此InnoDB引入了一个参数<code>innodb_optimize_fulltext_only</code>来控制该行为。当开启该选项时，如果执行optimize table，就只优化全文索引，而不会去重建表，入口函数为ha_innobase::optimize：</p>

<pre><code class="language-c">ha_innobase::optimize
     |--&gt; fts_sync_table
     |--&gt; fts_optimize_table
</code></pre>

<p>首先调用函数<code>fts_sync_table</code>，将表上在内存中cache的数据刷到全文索引文件中；<br />
然后调用函数<code>fts_optimize_table</code>，我们主要分析集中在第二步。</p>

<p><code>fts_optimize_table</code>函数流程如下：</p>

<ul>
  <li>
    <p>如果BEGING_DELETED表中没有数据（例如第一次调用optimized table），则将DELETED表中的数据转储到BEING_DELETED表中，相当于拿到了一个快照，执行的SQL操作为：</p>

    <pre><code>  static  const char* fts_init_delete_sql =
          "BEGIN\n"
          "\n"
          "INSERT INTO $BEING_DELETED\n"
                  "SELECT doc_id FROM $DELETED;\n"
          "\n"
          "INSERT INTO $BEING_DELETED_CACHE\n"
                  "SELECT doc_id FROM $DELETED_CACHE;\n";
</code></pre>
  </li>
</ul>

<p>参考函数：<code>fts_optimize_create_deleted_doc_id_snapshot</code></p>

<ul>
  <li>
    <p>从BEING_DELETED/BEING_DELETED_CACHE表中读取已经被删除的doc id，这些doc id在随后的索引优化中将被忽略掉。<br />
参考函数：<code>fts_optimize_read_deleted_doc_id_snapshot</code></p>
  </li>
  <li>
    <p>调用<code>fts_optimize_indexes</code> 对每个索引进行优化，相关堆栈如下：</p>

    <pre><code>  fts_optimize_indexes
       |--&gt; fts_optimize_index
              |--&gt; fts_optimize_index_read_words
                      // 读入需要进行优化的分词，一轮优化的个数不超过innodb_ft_num_word_optimize的配置值
                      // 缓存的分词数据采用zlib进行压缩
              |--&gt; fts_optimize_words // 读取分词，将已经删除的doc id从其中清除，并回写到db
                      |--&gt; fts_index_fetch_nodes // 逐个读取分词对应的全文索引项
                      |--&gt; fts_optimize_compact
                           |--&gt; fts_optimize_word // 判断是否包含被删除的doc id，并重组记录
                           |--&gt; fts_optimize_write_word // 将记录写回索引，具体操作为先删除老的记录，再插入新的记录
                           |--&gt; fts_config_set_index_value //更新CONFIG表的FTS_LAST_OPTIMIZED_WORD列，记录最近重组优化的分词
        |--&gt; fts_optimize_index_completed // 若上述步骤将读取的分词全部处理完了，则本轮optimize操作完成
</code></pre>
  </li>
  <li>
    <p>当在所有索引上完成optimize后，调用fts_optimize_purge_snapshot，主要操作包括：</p>

    <ul>
      <li>
        <p>从DELETE和DELETE_CACHE表中将doc id删除，参考函数fts_optimize_purge_deleted_doc_ids</p>

        <pre><code>  static const char* fts_delete_doc_ids_sql =
          "BEGIN\n"
          "\n"
          "DELETE FROM $DELETED WHERE doc_id = :doc_id1;\n"
          "DELETE FROM $DELETED_CACHE WHERE doc_id = :doc_id2;\n";
</code></pre>
      </li>
      <li>
        <p>从BEING_DELETED及BEING_DELETED_CACHE中删除对应的doc id。</p>

        <pre><code>  static const char* fts_end_delete_sql =
          "BEGIN\n"
          "\n"
          "DELETE FROM $BEING_DELETED;\n"
          "DELETE FROM $BEING_DELETED_CACHE;\n";
</code></pre>

        <p>参考函数： <code>fts_optimize_purge_deleted_doc_id_snapshot</code></p>
      </li>
    </ul>
  </li>
</ul>

<h2>后台线程</h2>
<p>InnoDB启动时，会创建一个后台线程，线程函数为<code>fts_optimize_thread</code>，工作队列为<code>fts_optimize_wq</code>，其主要目的是在满足一定条件时，对表自动进行optimize操作。</p>

<p>在如下两种情况，会向<code>fts_optimize_wq</code>中增加元组：</p>

<ul>
  <li><code>fts_optimize_add_table</code>: 创建或打开一个新的带全文索引的表时，创建一个类型为<code>FTS_MSG_ADD_TABLE</code>并包含表对象指针的MSG，加入到<code>fts_optimize_wq</code>中，这些表禁止被从数据词典中驱逐；</li>
  <li><code>fts_optimize_remove_table</code>: 删除表、DDL、释放表对象(<code>dict_mem_table_free</code>)、删除全文索引(<code>fts_drop_index</code>)等操作时，会创建一个类型为<code>FTS_MSG_DEL_TABLE的MEG</code>，加入到<code>fts_optimize_wq</code>队列中。</li>
</ul>

<p>fts optimize线程对于FTS_MSG_ADD_TABLE类型的会将相应的表加入到调度队列，对于FTS_MSG_DEL_TABLE，则从调度队列中删除。其调度队列的成员类型为<code>fts_slot_t</code>。</p>

<p>当表上删除的数据量超过一千万(FTS_OPTIMIZE_THRESHOLD)行时，就会触发一次自动optimize table，但两次optimize的间隔不应低于300秒（FTS_OPTIMIZE_INTERVAL_IN_SECS）。</p>

<h2>监控</h2>

<p>我们可以通过几个INFORMATION_SCHEMA下的全文索引表来监控全文索引状态。</p>

<pre><code>mysql&gt; show tables like '%ft%';
+-------------------------------------+
| Tables_in_information_schema (%ft%) |
+-------------------------------------+
| INNODB_FT_CONFIG                    |
| INNODB_FT_BEING_DELETED             |
| INNODB_FT_DELETED                   |
| INNODB_FT_DEFAULT_STOPWORD          |
| INNODB_FT_INDEX_TABLE               |
| INNODB_FT_INDEX_CACHE               |
+-------------------------------------+
6 rows in set (0.00 sec)
</code></pre>

<p>想要从information_schema表中查询信息，需要先设置变量<code>innodb_ft_aux_table</code>，值为你要查询表的”dbname/tablename”。</p>

<h2>全文索引停词</h2>

<p>停词(STOP WORD)用于在分词时忽略那些常见的不重要的单词，InnoDB目前内建的停词可以从information_schema.INNODB_FT_DEFAULT_STOPWORD读取，用户也可以自己定义停词列表，方法很简单：创建一个和nformation_schema.INNODB_FT_DEFAULT_STOPWORD一模一样的表，将你想要的停词加入到其中，然后设置<code>innodb_ft_server_stopword_table</code>值为你创建的表名：”dbname/tabname”。</p>

<p>你也可以使用会话级别的参数<code>innodb_ft_user_stopword_table</code>来指定你想要的停词表，和上述创建规则一致，具体的参阅<a href="http://dev.mysql.com/doc/refman/5.7/en/fulltext-stopwords.html">官方文档</a>。</p>

<p>另外配置项<code>innodb_ft_min_token_size</code>及<code>innodb_ft_max_token_size</code> 用于表示一个单词的字符长度范围，在这个范围的连续字符串才会被当作一个单词。然而如果使用ngram解析器的话，有效单词长度受参数<code>ngram_token_size</code>控制。</p>

<p>可以关闭参数<code>innodb_ft_enable_stopword</code>，这样在分词时也会把预设的停词考虑进去。</p>

<h2>InnoDB全文索引插件</h2>

<p>从MySQL 5.7.3开始InnoDB支持全文索引插件，用户可以以Plugin的模式来定义自己的分词规则，或是引入社区开发的全文索引解析器，例如某些专业领域的分词，可能具有不同的规则。</p>

<p>全文索引插件有两种角色：第一种是替换内建的parser，读取输入文档，进行解析后，将分词传送给server；另一种角色是作为内建parser的协作者，可以把输入文档处理过后，再传送给内建parser。</p>

<p>如果你已经有一个基于MYISAM的全文索引插件了，也可以根据<a href="http://mysqlserverteam.com/innodb-supports-plugin-parser-in-fulltext-index/">这篇官方文档</a>的介绍，将其修改成InnoDB全文索引插件。</p>

<h2>InnoDB N-gram parser</h2>

<p>从MySQL5.7.6版本开始提供了一种内建的全文索引ngram parser，可以很好的支持CJK字符集（中文、日文、韩文），CJK有个共同点就是单词不像英语习惯那样根据空格进行分解的，因此传统的内建分词方式无法准确的对类似中文进行分词。</p>

<p>ngram parser内建在代码中，该解析器默安装，你可以通过指定索引属性（<code>WITH PARSER ngram</code>）来利用该parser，例如：</p>

<pre><code>mysql&gt; create table ft_test(id int, content text, fulltext (content) with parser ngram);
Query OK, 0 rows affected (0.26 sec)
</code></pre>

<p>N-Gram使用一种特殊的方式来进行分词，举个简单的例子，假设要对单词’abcd’进行分词，那么其分词结果为：</p>

<pre><code>N=1 : 'a', 'b', 'c', 'd';
N=2 : 'ab', 'bc', 'cd';
N=3 : 'abc', 'bcd';
N=4 : 'abcd';
</code></pre>

<p>N取决于<code>ngram_token_size</code>的设置，默认值为2。</p>

<p>对于停词的处理，N-Gram和默认的parser不同，即只要每个token包含了（而不是精确匹配）停词，就不对其进行索引；另外空格总是作为一个停词，因此在分词取token时，空格会被忽略掉。</p>

<p>在执行查询时，用户传递的搜索词也会基于N-Gram进行分解后进行检索。 具体的例子可以参阅<a href="http://mysqlserverteam.com/innodb-full-text-n-gram-parser/">官方博客</a>的描述。</p>

<p>除了N-gram parser外，官方也支持了另外一种名为<a href="http://mysqlserverteam.com/innodb-full-text-mecab-parser/">MeCab Parser</a>的插件，主要用于日语分词，但需要手动安装。</p>


    </section>
  </div>
</div>


    <footer>
  <a href="http://mysql.taobao.org/" target="_blank" class="muted">阿里云RDS-数据库内核组</a>
  <br>
  <a href="https://github.com/alibaba/AliSQL" target="_blank" class="muted">欢迎在github上star AliSQL</a>
</br>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">知识共享署名-非商业性使用-相同方式共享 3.0 未本地化版本许可协议</a>进行许可。
</footer>

<script type="text/javascript">
  jQuery(document).ready(function($){
    // browser window scroll (in pixels) after which the "back to top" link is shown
    var offset = 300,
      //browser window scroll (in pixels) after which the "back to top" link opacity is reduced
      offset_opacity = 1200,
      //duration of the top scrolling animation (in ms)
      scroll_top_duration = 700,
      //grab the "back to top" link
      $back_to_top = $('.cd-top');

    //hide or show the "back to top" link
    $(window).scroll(function(){
      ( $(this).scrollTop() > offset ) ? $back_to_top.addClass('cd-is-visible') : $back_to_top.removeClass('cd-is-visible cd-fade-out');
      if( $(this).scrollTop() > offset_opacity ) {
        $back_to_top.addClass('cd-fade-out');
      }
    });

    //smooth scroll to top
    $back_to_top.on('click', function(event){
      event.preventDefault();
      $('body,html').animate({
        scrollTop: 0 ,
        }, scroll_top_duration
      );
    });

  });
</script>



    <a href="#0" class="cd-top"><svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="10px"
   width="38px" height="60px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
      <polygon fill="#FFFFFF" points="8,2.8 16,10.7 13.6,13.1 8.1,7.6 2.5,13.2 0,10.7 "/>
    </svg>
    </a>
  </body>

</html>
